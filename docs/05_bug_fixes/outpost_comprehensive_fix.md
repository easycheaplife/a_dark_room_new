# 前哨站系统全面修复

## 问题描述

**多个前哨站相关问题**:
1. 探索地图时，其他地形（O，V等）转变黑色P后，再访问黑色的P，不变灰
2. 灰色的P可以访问，访问灰色的P时，其他黑色的P也变灰了
3. ✅ **已修复** 访问P后，不能再访问，然后返回村庄，再进入地图，又可以访问P了
4. 前哨站使用逻辑与原游戏不一致

**最新问题**:
5. ✅ **已修复** 访问黑色P后，变灰色P，不能再访问，然后返回村庄，再进入地图，又可以访问灰色P了

**当前问题**:
6. ✅ **已修复** 访问黑色P后，变灰色P，不能再访问，然后返回村庄，再进入地图，灰色P变成了黑色的P了

**最新问题**:
7. 访问黑色P后，变灰色P，不能再访问，然后返回村庄，再进入地图，灰色P又可以访问了

**症状**:
- 前哨站显示状态混乱（黑色/灰色显示不正确）
- 前哨站访问逻辑错误（已使用的前哨站仍可访问）
- 状态重置机制不正确（回村庄后状态异常）
- 地图显示逻辑使用错误的位置检查
- **新症状**：前哨站使用后变灰，回村庄再出发又变黑
- **最新症状**：前哨站使用后变灰，回村庄再出发，灰色前哨站又可以访问

## 根本原因分析

### 原游戏逻辑（正确的）

通过分析原游戏代码 `adarkroom/script/world.js`：

1. **地图显示逻辑**:
   ```javascript
   // world.js:1200-1202
   if(typeof World.LANDMARKS[c] != 'undefined' && 
      (c != World.TILE.OUTPOST || !World.outpostUsed(i, j))) {
       // 显示为黑色地标
   }
   ```

2. **前哨站访问逻辑**:
   ```javascript
   // world.js:1250-1252
   if(curTile != World.TILE.OUTPOST || !World.outpostUsed()) {
       // 可以触发事件
   }
   ```

3. **前哨站使用函数**:
   ```javascript
   // world.js:1067-1072
   useOutpost: function() {
     Notifications.notify(null, _('water replenished'));
     World.setWater(World.getMaxWater());
     // Mark this outpost as used
     World.usedOutposts[World.curPos[0] + ',' + World.curPos[1]] = true;
   }
   ```

4. **状态重置**:
   ```javascript
   // world.js:1030
   onArrival: function() {
     World.usedOutposts = {};
   }
   ```

### Flutter实现的问题

1. **地图显示逻辑错误**:
   ```dart
   // 错误：使用当前位置检查，而不是指定位置
   final isUsedOutpost = (originalTile == 'P' && world.outpostUsed());
   ```

2. **访问逻辑混乱**:
   ```dart
   // 错误：同时调用markVisited和markOutpostUsed
   markOutpostUsed();
   markVisited(curPos[0], curPos[1]); // 这行是多余的！
   ```

3. **状态持久化错误**:
   ```dart
   // 错误：保存临时状态到持久化存储
   sm.set('game.world.usedOutposts', usedOutposts);
   ```

## 解决方案

### 修改1: 修复地图显示逻辑

**文件**: `lib/screens/world_screen.dart`
**位置**: 第228-238行

**修改前**:
```dart
final isUsedOutpost = (originalTile == 'P' && world.outpostUsed());
```

**修改后**:
```dart
// 修复：使用指定位置检查前哨站是否已使用，而不是当前位置
final isUsedOutpost = (originalTile == 'P' && world.outpostUsed(x, y));
```

### 修改2: 修复前哨站访问逻辑

**文件**: `lib/modules/world.dart`
**位置**: 第912-949行

**修改前**:
```dart
if (!isUsed) {
    // 触发事件
} else {
    Logger.info('🏛️ 前哨站已使用或已访问，跳过事件');
}
```

**修改后**:
```dart
// 参考原游戏：只有未使用的前哨站才能触发事件
if (!isUsed) {
    // 触发事件
} else {
    Logger.info('🏛️ 前哨站已使用，跳过事件（但仍可访问）');
    // 参考原游戏：已使用的前哨站仍然可以访问，只是不提供补水功能
}
```

### 修改3: 修复前哨站访问状态逻辑

**文件**: `lib/modules/world.dart`
**位置**: 第1798-1802行

**问题**: 前哨站使用后被错误标记为已访问，导致状态重置异常

**修改前**:
```dart
// 同时标记前哨站为已使用和已访问，确保状态同步
Logger.info('🏛️ 调用 markOutpostUsed()');
markOutpostUsed();
Logger.info('🏛️ 调用 markVisited()');
markVisited(curPos[0], curPos[1]);
```

**最新修改后**:
```dart
// 修复：前哨站使用后需要标记为已访问，确保回村庄后显示状态正确
// 虽然使用状态会重置，但访问状态是永久的，保证显示一致性
Logger.info('🏛️ 调用 markOutpostUsed()');
markOutpostUsed();
Logger.info('🏛️ 调用 markVisited() - 确保前哨站使用后显示为灰色');
markVisited(curPos[0], curPos[1]);
```

**问题根因重新分析**:
- 前哨站的显示状态依赖于两个条件：使用状态和访问状态
- 使用状态是临时的（每次出发重置），访问状态是永久的
- 如果前哨站使用后不标记为已访问，回村庄后会因为使用状态重置而重新显示为黑色
- **解决方案**：前哨站使用后必须标记为已访问，确保显示状态的一致性

### 修改4: 修复状态持久化

**文件**: `lib/modules/world.dart`
**位置**: 第1396-1400行

**修改前**:
```dart
if (usedOutposts.isNotEmpty) {
    sm.set('game.world.usedOutposts', usedOutposts);
    Logger.info('🏛️ 保存前哨站使用状态: ${usedOutposts.length} 个已使用');
}
```

**修改后**:
```dart
// 参考原游戏：前哨站使用状态是临时的，不保存到持久化存储
// 每次出发时会重置usedOutposts = {}
Logger.info('🏛️ 前哨站使用状态不持久化（参考原游戏逻辑）');
```

### 修改5: 修复前哨站访问条件判断

**文件**: `lib/modules/world.dart`
**位置**: 第920-949行

**问题**: 前哨站访问条件不完整，只检查使用状态，没有检查访问状态

**修改前**:
```dart
// 参考原游戏：只有未使用的前哨站才能触发事件
if (!isUsed) {
    // 触发事件
} else {
    Logger.info('🏛️ 前哨站已使用，跳过事件（但仍可访问）');
    // 参考原游戏：已使用的前哨站仍然可以访问，只是不提供补水功能
}
```

**修改后**:
```dart
// 修复：前哨站访问条件应该同时检查使用状态和访问状态
// 只有未访问且未使用的前哨站才能触发事件
if (!isVisited && !isUsed) {
    // 触发事件
} else {
    if (isVisited) {
        Logger.info('🏛️ 前哨站已访问，跳过事件');
    } else if (isUsed) {
        Logger.info('🏛️ 前哨站已使用，跳过事件');
    }
    // 已访问或已使用的前哨站不再触发事件
}
```

**修复逻辑**:
- 前哨站使用后会被标记为已访问（永久状态）
- 前哨站使用状态是临时的（每次出发重置）
- 访问条件必须同时检查两个状态，确保已访问的前哨站不会重复触发事件

## 技术细节

### 前哨站状态系统

前哨站有两个独立的状态：

1. **已使用状态** (`usedOutposts`):
   - 临时状态，每次出发重置
   - 控制前哨站是否可以再次使用
   - 影响地图显示逻辑（黑色/灰色）

2. **已访问状态** (`!`标记):
   - 持久状态，保存到StateManager
   - 控制地标的视觉显示
   - 由其他机制管理，不在前哨站使用时处理

### 正确的前哨站生命周期

1. **创建**: `clearDungeon`创建前哨站，不带访问标记
2. **显示**: 未使用时显示为黑色地标，已使用时显示为灰色地形
3. **访问**: 只有未使用的前哨站可以触发补水事件
4. **重置**: 每次出发时重置所有使用状态

## 验证结果

### 修复前
- ❌ 地图显示逻辑错误，使用当前位置而非指定位置
- ❌ 前哨站访问后错误标记为已访问
- ❌ 状态持久化导致重置失效
- ❌ 前哨站状态重置异常，回村庄后又可访问
- ❌ 前哨站使用后变灰，回村庄再出发又变黑
- ❌ **最新问题**：前哨站访问条件不完整，已访问的前哨站仍可触发事件
- ❌ 与原游戏逻辑不一致

### 最终修复后
- ✅ 地图显示使用正确的位置检查
- ✅ 前哨站使用后标记为已使用和已访问
- ✅ 状态正确重置，不持久化临时状态
- ✅ 前哨站显示状态保持一致（使用后永远显示为灰色）
- ✅ 解决了显示状态重置问题
- ✅ **修复访问条件判断**：同时检查使用状态和访问状态
- ✅ 已访问的前哨站不再触发事件，完全符合游戏逻辑

### 最终解决方案
经过深入分析发现：
1. **前哨站显示状态的双重依赖**：既依赖使用状态，也依赖访问状态
2. **使用状态是临时的**：每次出发重置，用于控制当次出发的使用限制
3. **访问状态是永久的**：用于控制地图显示的视觉一致性和事件触发
4. **访问条件的完整性**：必须同时检查使用状态和访问状态
5. **最终方案**：前哨站使用后标记为已访问，访问条件检查两个状态，确保逻辑完整性

## 相关文件
- `lib/modules/world.dart` - 主要修改文件
- `lib/screens/world_screen.dart` - 地图显示逻辑
- `adarkroom/script/world.js` - 原游戏参考

## 测试建议
1. 清理地牢创建前哨站，确认显示为黑色
2. 访问前哨站，确认补水功能和状态变化
3. 验证其他前哨站不受影响
4. 回到村庄再出发，确认状态正确重置
5. 测试已使用前哨站的访问行为
